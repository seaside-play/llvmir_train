# LLVM IR
## LLVM编译流程
LLVM IR是LLVM项目的核心，对于每个编译器而言，为了方便对不同的高级语言进行优化以及代码生成（codegen），其会根据目标语言产生统一的中间表示（Intermediate Representation，IR），这种中间表示既与源语言无关，也与目标架构无关。随后只需要在统一的IR上实现一套相同的pass即可，避免了为不同的高层级语言设计多套不同的pass和codegen。整个编译的流程可以近似看作下图1所示。

图2 编译器的编译流程示意图     
![编译器的编译流程示意图](./process.png)  


其中，不同的高级语言会通过前端的处理（词法分析、语法分析、语义分析等）生成特定的数据结构（如抽象语法树），随后这些数据结构会被发射（emit）成相应的LLVM IR进行独立于源语言和目标架构的统一表示。接下来，LLVM opt会对这些IR执行指定的pass，常见的如Dead Code Elimination，Loop Invariant Code Motion等。每个pass的输入都是LLVM IR，输出同样也是LLVM IR。最后，经过优化的LLVM IR会送入编译器后端，被转换为Selection Directed Acyclic Graph（Selection DAG），并最终发射为目标架构的汇编指令。

## LLVM IR的设计思想
对于一个多前端、多目标架构的编译器而言，选择IR既不能选择过于高层级的IR，因为太过与靠近源语言，很难做一些目标架构相关的优化，也不能选择过于低层级的IR，因为太靠近目标架构的机器指令，不够通用且看不到高层级的流程思想，很多优化无法实施。

LLVM IR在能够清楚的看清高层级语言想法的基础上，处于一个尽可能低层级的位置，通过这样的定位来使自己成为一种通用的R。

理想情况下LLVM R应该是目标架构的无关的，但是并非如此，因为有些语言本身就对目标架构具有依赖性。比如在使用Linux系统的标准C头文件时，这个头文件本身就是与目标架构相关的，可能需要制定一个特定的架构类型来匹配不同的系统调用

## LLVM的形式
LLVM具有以下三种等价的形式：

内存形式
保存在硬盘上的bitcode
适合人类阅读的形式（LLVM汇编）
